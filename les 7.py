#1.Реализовать класс Matrix (матрица). Обеспечить перегрузку конструктора класса (метод __init__()), который должен принимать данные (список списков) для формирования матрицы.
#Подсказка: матрица — система некоторых математических величин, расположенных в виде прямоугольной схемы.
#Примеры матриц: 3 на 2, 3 на 3, 2 на 4.

#31    32         3    5    32        3    5    8    3
#37    43         2    4    6         8    3    7    1
#51    86        -1   64   -8
class Matrix:
    def __init__(self, matrix): #инициализация экземпляров класса
        self.matrix = matrix


#Следующий шаг — реализовать перегрузку метода __str__() для вывода матрицы в привычном виде.
    def __str__(self):
        pass
#Далее реализовать перегрузку метода __add__() для реализации операции сложения двух объектов класса Matrix (двух матриц). Результатом сложения должна быть новая матрица.
#Подсказка: сложение элементов матриц выполнять поэлементно — первый элемент первой строки первой матрицы складываем с первым элементом первой строки второй матрицы и т.д.
class Matrix:
    def __init__(self, matrix):
        self.matrix = matrix

    def __str__(self):
        s = ''
        for i in range(len(self.matrix)):
            s = s + '\t'.join(map(str, self.matrix[i])) + '\n'                  # уажется я поняла, как оформить таблицу, как вы говорили на занятии. Вокруг каждого числа обрисовать нижними подчеркиваниями?
        return s

    def __add__(self, other):
        if len(self.matrix) != len(other.matrix):
            return "Вы не можете сложить матрицы разной размерности"
        res = {}
                                           #Никак не получается понять в чем проблема. Подскажите, чем это лечить? В словарь тоже не сохраняет по-человечески
        for i in range(len(self.matrix)):
            for j in range(len(self.matrix)):
                res[i][j] = self.matrix[i][j] + other.matrix[i][j]

        return Matrix(res)


matr1 = [[31, 32], [37, 43], [51, 86]]
matr2 = [[3, 5], [2, 4], [5, 6]]
m = Matrix(matr1)
s = Matrix(matr2)
print(s + m)












#2. Реализовать проект расчёта суммарного расхода ткани на производство одежды. Основная сущность (класс) этого проекта — одежда, которая может иметь определённое название.
#К типам одежды в этом проекте относятся пальто и костюм. У этих типов одежды существуют параметры: размер (для пальто) и рост (для костюма). Это могут быть обычные числа: V и H, соответственно.
#Для определения расхода ткани по каждому типу одежды использовать формулы: для пальто (V/6.5 + 0.5), для костюма (2*H + 0.3). Проверить работу этих методов на реальных данных.
#Реализовать общий подсчет расхода ткани. Проверить на практике полученные на этом уроке знания: реализовать абстрактные классы для основных классов проекта,
# проверить на практике работу декоратора @property.

class Сlothes:
    def __init__(self, v, h):
        self.size = v
        self.height = h

    def get_size(self):
        return self.size


    def get_height(self):
        return self.height

    @property
    def get_sq_full(self):
        return f'Расчет затрат ткани: {(self.size / 6.5 + 0.5) + (self.height * 2 + 0.3)}'

class Coat (Сlothes):

    def __init__(self, v, h):
        super().__init__(v, h)
        self.square_c = self.size / 6.5 + 0.5

    def __str__(self):
        return f'Потребуется ткани на пальто: {self.square_c}'

class Suit (Сlothes):
    def __init__(self, v, h):
        super().__init__(v, h)
        self.square_s = self.height * 2 + 0.3

    def __str__(self):
        return f'Потребуется ткани на костюм: {self.square_s}'

coat = Coat (42, 173)
suit = Suit (42, 173)
print(coat)
print(suit)
print(coat.get_sq_full)
print(suit.get_sq_full)
print(suit.get_size())
print(suit.get_height())



#3. Реализовать программу работы с органическими клетками, состоящими из ячеек. Необходимо создать класс Клетка. В его конструкторе инициализировать параметр,
#соответствующий количеству ячеек клетки (целое число). В классе должны быть реализованы методы перегрузки арифметических операторов:
# сложение (__add__()), вычитание (__sub__()), умножение (__mul__()), деление (__truediv__()). Данные методы должны применяться только к клеткам и выполнять увеличение, уменьшение, умножение и целочисленное (с округлением до целого) деление клеток, соответственно.
#Сложение. Объединение двух клеток. При этом число ячеек общей клетки должно равняться сумме ячеек исходных двух клеток.
#Вычитание. Участвуют две клетки. Операцию необходимо выполнять только если разность количества ячеек двух клеток больше нуля, иначе выводить соответствующее сообщение.
#Умножение. Создаётся общая клетка из двух. Число ячеек общей клетки определяется как произведение количества ячеек этих двух клеток.
#Деление. Создаётся общая клетка из двух. Число ячеек общей клетки определяется как целочисленное деление количества ячеек этих двух клеток.

#В классе необходимо реализовать метод make_order(), принимающий экземпляр класса и количество ячеек в ряду. Данный метод позволяет организовать ячейки по рядам.
#Метод должен возвращать строку вида *****\n*****\n*****..., где количество ячеек между \n равно переданному аргументу. Если ячеек на формирование ряда не хватает, то в последний ряд записываются все оставшиеся.
#Например, количество ячеек клетки равняется 12, количество ячеек в ряду — 5. Тогда метод make_order() вернёт строку: *****\n*****\n**.
#Или, количество ячеек клетки равняется 15, количество ячеек в ряду — 5. Тогда метод make_order() вернёт строку: *****\n*****\n*****.
#Подсказка: подробный список операторов для перегрузки доступен по ссылке.

class Cell:
    def __init__(self, cellule):
        self.cellule = cellule

    def __add__(self, other):
        return Cell(self.cellule + other.cellule)

    def __sub__(self, other):
        if self.cellule - other.cellule > 0:
            return Cell(self.cellule - other.cellule)
        else:
            return f'Операция вычитания невозможна'

    def __mul__(self, other):
        return Cell(self.cellule * other.cellule)

    def __truediv__(self, other):
        return Cell(self.cellule // other.cellule)

#make_order() - не хватило времени